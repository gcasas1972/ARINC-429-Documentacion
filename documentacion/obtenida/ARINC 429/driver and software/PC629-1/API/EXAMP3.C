
#include <windows.h>
#include <stdio.h>
#include "p61w32.h"

/**
*
*   PC629-1 EXAMPLE 3 PROGRAM  Version 1.0  (07/05/2002)
*   Copyright (c) 1999-2002
*   Ballard Technology, Inc.
*   www.ballardtech.com
*   support@ballardtech.com
*   ALL RIGHTS RESERVED
*
*   NAME:   EXAMP3.C -- Interrupt Example Program.
*
**/

/**
*
*   This program is identical to EXAMP2.C which implements
*   the landing gear simulator described in Section 3.3 of
*   the PC629-1 User's Manual except for two features.
*   
*   1) Instead of using EXAMP2.ROM, it configures the
*   personality PROMs by writing them directly.
*
*   2) It enables interrupts from the PC629-1 card and spawns
*   a worker thread.  Whenever an interrupt is generated by
*   the card upon receipt of label 134H, it reads the lever
*   position and modifies the landing gear positions.
*
*   To compile this program with the Microsoft C++ compiler,
*   use the following command line:
*
*   CL EXAMP3.C P61W32.LIB
*
*   To compile this program with the Borland C++ compiler, use
*   the following command line:
*
*   BCC32 EXAMP3.C P61W32.LIB
*
**/

HCARD handleval;

INT ti=50;							//Transmit interval value
INT tg=8;							//Terminal gap value
INT sg=0;							//Sync gap value

const INT XPP_BASE  = 0x0000;		//Base address of XPP
const INT RPP_BASE  = 0x8000;		//Base address of RPP
const INT CFG_BASE  = 0xFFE0;		//Base address of configuration table

WORD wLever;
WORD wLeftGear;
WORD wRightGear;
WORD wNoseGear;

typedef struct                      //Variables used by the thread
{
	BOOL      fWindowsNT40;         //Flags whether we are running under Windows NT 4.0
	BOOL      fStayAlive;           //Flag indicating the thread should stay alive
	BOOL      fHasQuit;             //Flag indicating the thread has quit
	ULONG     Hits;                 //Counting variable
	ULONG     Misses;               //Counting variable
	HANDLE    hEvent;               //Handle of event
	HANDLE    hThread;              //Handle of event
} ThreadMailbox;

/**
*
*  This is the interrupt service thread.  It waits for the
*  event object to be set to the signaled state.  When an
*  interrupt is generated from the PC629-1 card, the event
*  object is set to the signaled state and the thread resumes
*  operation.  It then reads the lever position and modifies
*  the gear position values.
*
**/

DWORD WINAPI InterruptServiceThread(LPVOID lpParam)
{
	ThreadMailbox *pMailbox = (ThreadMailbox*)lpParam;

	pMailbox->fStayAlive = TRUE;
	pMailbox->fHasQuit   = FALSE;
	pMailbox->Hits       = 0;
	pMailbox->Misses     = 0;

	while(pMailbox->fStayAlive)
	{
		if (WaitForSingleObject(pMailbox->hEvent,200) == WAIT_TIMEOUT)
		{
			pMailbox->Misses++;                //Increment counter
		}
		else
		{
			if (!pMailbox->fWindowsNT40)      //Reset event if not Windows NT 4.0
			{                                 //to allow another event
				ResetEvent(pMailbox->hEvent);
			}

			pMailbox->Hits++;                //Increment counter

			wLever  = PC629_RamRdW(0,0x40,handleval);				//Read lever position

			wLeftGear  = PC629_RamRdW(0,0x60,handleval);			//Read old left gear position
			wRightGear = PC629_RamRdW(0,0x61,handleval);			//Read old right gear position
			wNoseGear  = PC629_RamRdW(0,0x62,handleval);			//Read old nose gear position

			wLeftGear  = (wLeftGear  > 0x80) ? 0x80 : wLeftGear;	//Put position in bounds
			wRightGear = (wRightGear > 0x80) ? 0x80 : wRightGear;	//Put position in bounds
			wNoseGear  = (wNoseGear  > 0x80) ? 0x80 : wNoseGear;	//Put position in bounds

			if (wLever==1)											//If lever in up position
			{
				if (wLeftGear  != 0x00) --wLeftGear;				//Move left gear up
				if (wRightGear != 0x00) --wRightGear;				//Move right gear up
				if (wNoseGear  != 0x00) --wNoseGear;				//Move nose gear up
			}
			else if (wLever==2)										//If lever in down position
			{
				if (wLeftGear  != 0x80) ++wLeftGear;				//Move left gear down
				if (wRightGear != 0x80) ++wRightGear;				//Move right gear down
				if (wNoseGear  != 0x80) ++wNoseGear;				//Move nose gear down
			}

			PC629_RamWrW(0,0x60,wLeftGear, handleval);				//Write left gear position
			PC629_RamWrW(0,0x61,wRightGear,handleval);				//Write right gear position
			PC629_RamWrW(0,0x62,wNoseGear, handleval);				//Write nose gear position

			PC629_RegRdVect(handleval);

			PC629_IntClr(handleval);
		}
	}

	pMailbox->fHasQuit = TRUE;                //Set flag indicating we have quit

	return(0);
}

VOID main(VOID)
{
	INT label;
	INT row,col;
	ERRVAL errval;
	INT ch;
	BOOL done;
	INT j;
	INT cid;
	BYTE value0;
	BYTE value1;
	BYTE rppcell[8];
	BYTE xppcell[8];
	BYTE ymod[8];
	BOOL fWindowsNT40;
	ThreadMailbox Mailbox;
	DWORD ThreadId;
	OSVERSIONINFO OSInfo;

	fprintf(stderr,"\nEXAMP3  Version 1.0  (07/05/2002)");
	fprintf(stderr,"\nCopyright 1999-2002  Ballard Technology, Inc.  Everett, WA, USA.");
	fprintf(stderr,"\nAll rights reserved.");
	fprintf(stderr,"\nGo to www.ballardtech.com or email support@ballardtech.com");
	fprintf(stderr,"\n");
	fprintf(stderr,"\nExample 3 - Interrupt example program");
	fprintf(stderr,"\n");

/**
*
*  Determine which OS we're running.  Interrupt handling is
*  slightly different between NT and all others.
*
**/

	OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&OSInfo))
	{
		fWindowsNT40 = ((VER_PLATFORM_WIN32_NT == OSInfo.dwPlatformId) &&
		                (OSInfo.dwMajorVersion <= 4));
	}
	else
	{
		printf("\nError:  Unable to determine the operating system");
		printf("\n        we are running on.");
		printf("\n");
		exit(1);
	}

/**
*
*   The following statement checks for the presence of a
*   PC629-1 card.
*
**/

	handleval = PC629_CardOpenEx(0);

	if (handleval<0)					//Check for card
	{
		printf("\nUnable to open PC629-1 card number %u (%i).",0,handleval);
		exit(1);
	}

/**
*
*   Reset the PC629-1 card.
*
**/

	PC629_Reset(handleval);

/**
*
*  Create an event object.  Under Windows NT, the event
*  object is created by the kernel driver and the application
*  opens it by name and passes the handle to the driver. 
*  Under all other Windows operating systems, the application
*  creates the event object and passes its handle to the
*  driver.
*
**/

	if (fWindowsNT40)
	{
		Mailbox.hEvent = OpenEvent(
			SYNCHRONIZE,                //Desired access
			FALSE,                      //Inherit flag
			"PC629Interrupt");          //Pointer to event-object name

		if (Mailbox.hEvent == NULL)
		{
			printf("\nEvent creation failed");
			printf("\nGetLastError returned %d",GetLastError());
			PC629_CardClose(handleval);
			exit(1);
		}
	}
	else
	{
		Mailbox.hEvent = CreateEvent(
			NULL,
			TRUE,                       //Flag for manual-reset event 
			FALSE,                      //Flag for initial state 
			NULL);                      //Pointer to event-object name  

		if (Mailbox.hEvent == NULL)
		{
			printf("\nEvent creation failed");
			printf("\nGetLastError returned %d",GetLastError());
			PC629_CardClose(handleval);
			exit(1);
		}
	}

/**
*
*  Install the interrupt handler for the card.
*
**/

	errval = PC629_IntInst(Mailbox.hEvent,OPT_NONE,handleval);

	if (errval < 0)
	{
		fprintf(stderr,"\nError:  Unable to install the interrupt handler.");
		fprintf(stderr,"\n");
		CloseHandle(Mailbox.hEvent);
		PC629_CardClose(handleval);
		exit(1);
	}

/**
*
*  Create a thread.
*
**/

	Mailbox.fWindowsNT40 = fWindowsNT40;

	Mailbox.fStayAlive = TRUE;
	Mailbox.fHasQuit   = FALSE;
	Mailbox.Hits       = 0;
	Mailbox.Misses     = 0;

	Mailbox.hThread = CreateThread(
		NULL,                   //Use the default security attributes  
		0x10000,                //Initial thread stack size
		InterruptServiceThread, //Pointer to thread function 
		(LPVOID)&Mailbox,       //Argument for new thread 
		0,                      //Creation flags 
		&ThreadId);             //Pointer to returned thread identifier 

	if (Mailbox.hThread == NULL)
	{
		printf("\nThread creation failed");
		printf("\nGetLastError = %d",GetLastError());
		CloseHandle(Mailbox.hEvent);
		PC629_CardClose(handleval);
		exit(1);
	}

/**
*
*	Fill the XPP & RPP of the PC629-1 with 1's.
*
**/

	PC629_PromFill(0xFF,handleval);

/**
*
*	Fill in the XPP cell for row 0, col 0.
*
**/

	row = 0;
	col = 0;

	xppcell[0] = 0x10;					//Label extension
	xppcell[1] = 0x64;					//Label value
	xppcell[2] = 0x00;					//RAM address, MSB
	xppcell[3] = 0x60;					//RAM address, LSB
	xppcell[4] = 0x3F;					//DATA, no EOM
	xppcell[5] = 0xFE;					//One data word
	xppcell[6] = 0xFF;					//Interrupt vector, MSB
	xppcell[7] = 0xFF;					//Interrupt vector, LSB

	PC629_PromWrS(xppcell,XPP_BASE+(row*8)+(col*0x100),8,handleval);

/**
*
*	Fill in the XPP cell for row 0, col 1.
*
**/

	row = 0;
	col = 1;

	xppcell[0] = 0x20;					//Label extension
	xppcell[1] = 0x64;					//Label value
	xppcell[2] = 0x00;					//RAM address, MSB
	xppcell[3] = 0x61;					//RAM address, LSB
	xppcell[4] = 0xBF;					//DATA, EOM
	xppcell[5] = 0xFE;					//One data word
	xppcell[6] = 0xFF;					//Interrupt vector, MSB
	xppcell[7] = 0xFF;					//Interrupt vector, LSB

	PC629_PromWrS(xppcell,XPP_BASE+(row*8)+(col*0x100),8,handleval);

/**
*
*	Fill in the XPP cell for row 1, col 0.
*
**/

	row = 1;
	col = 0;

	xppcell[0] = 0x40;					//Label extension
	xppcell[1] = 0x64;					//Label value
	xppcell[2] = 0x00;					//RAM address, MSB
	xppcell[3] = 0x62;					//RAM address, LSB
	xppcell[4] = 0xBF;					//DATA, EOM
	xppcell[5] = 0xFE;					//One data word
	xppcell[6] = 0xFF;					//Interrupt vector, MSB
	xppcell[7] = 0xFF;					//Interrupt vector, LSB

	PC629_PromWrS(xppcell,XPP_BASE+(row*8)+(col*0x100),8,handleval);

/**
*
*	Fill in the YMOD values.
*
**/

	row = 0x1F;
	col = 0;

	ymod[0] = 0x01;					//Number of last row
	ymod[1] = 0xFF;
	ymod[2] = 0xFF;
	ymod[3] = 0xFF;
	ymod[4] = 0xFF;
	ymod[5] = 0xFF;
	ymod[6] = 0xFF;
	ymod[7] = 0xFF;

	PC629_PromWrS(ymod,XPP_BASE+(row*8)+(col*0x100),8,handleval);

/**
*
*	Fill in all RPP cells for labels 000H-FFFH.
*
**/

	for (label=0;label<=0xFFF;++label)
	{
		for (j=0;j<8;++j)
		{
			rppcell[j] = 0xFF;					//Put 1's in cell
			rppcell[7] = 0x00;					//Except zero out last byte
		}

		PC629_PromWrS(rppcell,RPP_BASE+(label*8),8,handleval);
	}

/**
*
*	Fill in the RPP cell for label 134H.
*
**/

	label = 0x134;

	rppcell[0] = 0x00;					//RAM address, MSB
	rppcell[1] = 0x40;					//RAM address, LSB
	rppcell[2] = 0x7F;					//Enable LINT
	rppcell[3] = 0xFE;					//One data word
	rppcell[4] = 0x01;					//Interrupt vector, MSB
	rppcell[5] = 0x34;					//Interrupt vector, LSB
	rppcell[6] = 0x80;					//Zero OP
	rppcell[7] = 0x00;					//Zero OVR

	PC629_PromWrS(rppcell,RPP_BASE+(label*8),8,handleval);

/**
*
*	Fill in the MON cell for label 064H.
*
**/

	label = 0x064;

	rppcell[0] = 0xFF;					//RAM address, MSB
	rppcell[1] = 0xFF;					//RAM address, LSB
	rppcell[2] = 0x7D;					//Enable LINT
	rppcell[3] = 0xFE;					//One data word
	rppcell[4] = 0xFF;					//Interrupt vector, MSB
	rppcell[5] = 0xFF;					//Interrupt vector, LSB
	rppcell[6] = 0xFF;					//Disable OP
	rppcell[7] = 0x00;					//Zero OVR

	PC629_PromWrS(rppcell,RPP_BASE+(label*8),8,handleval);

/**
*
*	Fill in the RPP configuration table.
*
**/

	for (cid=0;cid<=0x0F;++cid)
	{
		value0 = ((sg<<6) & 0x80) + ((ti<<0) & 0x7F);
		value1 = ((sg<<7) & 0x80) + ((tg<<0) & 0x7F);

		PC629_PromWrB(CFG_BASE+(cid*2)+0,value0,handleval);
		PC629_PromWrB(CFG_BASE+(cid*2)+1,value1,handleval);
	}

/**
*
*   Apply TI,TG,SG to DATAC pins.
*
**/

	value0 = ((sg<<6) & 0x80) + ((ti<<0) & 0x7F);		//0x32
	value1 = ((sg<<7) & 0x80) + ((tg<<0) & 0x7F);		//0x08

	DRV629_RegWrTISG(value0,handleval);
	DRV629_RegWrTGSG(value1,handleval);

/**
*
*   Select XPP1, RPP1, and no MPP
*
**/

	DRV629_RegWrMemCfg(0x04,handleval);

/**
*
*   Disable ALT, enable BLOCK mode, use AXT.
*
**/

	DRV629_RegWrCID(0x38,handleval);

/**
*
*   Start the PC629-1 card.
*
**/

	PC629_Start(handleval);

/**
*
*  Display data.
*
**/

	printf("\nPress 'Q' to quit....");
	printf("\n");
	printf("\n");

	for (done=FALSE;!done;)
	{
		if (kbhit())
		{
			ch = getch();

			if (ch=='q' || ch=='Q')
			{
				done=TRUE;
			}
		}

		printf("\r");
		printf("Hits=%04X ",           Mailbox.Hits & 0xFFFF);
		printf("Misses=%04X ",         Mailbox.Misses & 0xFFFF);
		printf("Lever=%02X ",          wLever);
		printf("Gear=%04X/%04X/%04X ", wLeftGear,wNoseGear,wRightGear);
		printf("Err=%04X ",            PC629_RegRdErr(handleval));
		printf("Status=%02X ",         PC629_RegRdStatus(handleval));
		printf("LWM=%04X ",            PC629_RegRdLWM(handleval));
	}

/**
*
*  Clear the flag keeping the thread alive and wait for the
*  thread to quit.
*
**/

	printf("\nWaiting for the thread to quit.");
	
	Mailbox.fStayAlive = FALSE;                     //Clear the fStayAlive flag so the thread commits suicide after the next interrupt

	WaitForSingleObject(Mailbox.hThread,5000);		//Waiting for thread to quit

/**
*
*   Stop the PC629-1 card.
*
**/

	PC629_Stop(handleval);

/**
*
*   Release the handle to the PC629-1 card.
*
**/

	PC629_CardClose(handleval);

/**
*
*   Release the WIN32 handles.
*
**/

	CloseHandle(Mailbox.hThread);
	CloseHandle(Mailbox.hEvent);
}
